% -*- LaTeX -*-
%
% @file Overview.tex
% @brief OpenRTM-aist developers guide [Overview]
% @date $Date: 2005-05-12 09:06:21 $
% @author Noriaki Ando <n-ando@aist.go.jp>
%
% Copyright (C) 2003-2005
%     Task-intelligence Research Group,
%     Intelligent Systems Research Institute,
%     National Institute of
%         Advanced Industrial Science and Technology (AIST), Japan
%     All rights reserved.
%
% $Id$
%

\chapter{RTミドルウエア\index{RTミドルウエア}とは}

\section{RTミドルウエアの目的}
インターネットの広がりとともに、ロボットやロボットシステムをネットワーク化しネットワーク上のリソースを活用して、更なる知能化を目指す研究・開発が盛んに行われています。
しかしながら、これらのシステムの開発には通常膨大な開発技術者の投入及び、長い開発期間が必要で、ロボット製品として市場に提供できるだけのレベル、機能、価格のものはいまだほとんど世に出ていないのが現状です。
%ロボット工学は現在、日常生活に入り込み実際に何かの役に立つシステムを生み出すことを模索しています。

RTミドルウエアは、様々なロボット要素（RTコンポーネント\index{RTコンポーネント}）を通信ネットワークを介して自由に組み合わせることで、多様なネットワークロボットシステムの構築を可能にする、ネットワーク分散コンポーネント化技術による共通プラットフォームを確立することを目指しています。

ここでいうロボットシステムとは、必ずしも移動ロボットやヒューマノイドロボットといった単体のロボットのみを想定している訳ではなく、「ロボット技術を活用した、実世界に働きかける機能を持つネットワーク化された知能化システム」の総体としてのロボットシステムを指しています。
例えばセンサ、アクチュエータを生活空間の中に分散配置させ、ネットワークを介して協調することにより生活支援や介護を実現するといった、一見ロボットには見えないがロボット的な技術を利用したシステムを広く包含しています。
実際、センシング技術とセンサから得られる信号の処理、及びアクチュエータ等による現実世界への働きかけのフィードバックにより相互作用を行うシステムはロボット技術といってよいでしょう。
日本ロボット工業会が主体となり、こうしたロボット技術の総称を RT(RobotTechnology)\index{RT} と呼ぶことが提言されています。

RTミドルウエアはこうした技術(RT)の共通プラットフォームを整備し、ロボット研究・開発の効率を高め、RTの適用範囲を広げ、さらには新たな市場を拓くことを目指して現在も開発が続けられています。
ロボットシステムのソフトウェア開発においては、通常のソフトウェア開発と比べて、ロボットシステム特有の問題のためにソフトウェアの再利用性が低く開発効率が悪いといった問題が指摘されています。
こうした背景から、ロボット技術要素をソフトウェアレベルでモジュール化し、その再利用性を高めるミドルウェアを研究・開発し多くのユーザに使ってもらい、さらには開発に参加してもらうことで、ロボットシステム開発に資する共通プラットフォームを提供することがRTミドルウエアの目的なのです。


\section{RTミドルウエアの現状と課題}
OpenrRTM\--aist の開発は主に、我々、独立行政法人産業技術総合研究所・知能システム研究部門・タスクインテリジェンス研究グループにより行われています。
基は、平成14年度から平成16年度まで、独立行政法人新エネルギー・産業技術統合開発機構 (NEDO) の21世紀ロボットチャレンジプログラム「ロボット機能発現のために必要な要素技術開発」においてロボット用分散ミドルウェアの研究開発プロジェクトによりスタートしました。
この研究プロジェクトにおいて、分散ミドルウェアのインターフェースレベルでの仕様が策定され、プロトタイプ実装が完成しました。
本書は、そのプロトタイプ実装 OpenRTM\--aist\--0.2.0 の使用法等について解説するための本です。

上記プロジェクトでは、RTミドルウェアについてのコンセプトの議論及び、大枠でのインタフェースとこれに基づいたプロトタイプ実装が得られました。
しかしながら、これはあくまでサンプルの仕様および実装なので、実システムでの使用に耐えうるレベルにまではいたっていないのが現状です。
今後、多くのユーザからのフィードバックを基に実用的で詳細な仕様を策定し、リファレンスとなる実装を開発する必要があります。
OpenRTM\--aist\--0.2.0 はその足がかりとなる実装であり、今後多くの改良・改善が必要なレベルのソフトウエアであることをご承知おきください。

\section{RTミドルウエアの特長}

RTミドルウエアの特長を以下に挙げます。

\subsubsection*{RTシステムに特有な機能をサポートしている}
従来のネットワークロボット、情報家電や情報化ハウスなどIT分野を中心として類似のミドルウェアの提案がいくつかなされています。これらは、
%
\begin{itemize}
\item 個々の機器にコマンドを送る
\item ストリーミングを行う
\end{itemize}
%
などが主体であり、各機器を個別にネットワーク越しに使うことを中心に考えられており機器間の密な連携までは考慮されていません。
RTミドルウエアでは、コマンドフローとデータフローを明示的に分離し機器間の密な連携を意識した設計となっています。
ネットワーク上のコンポーネントは互いに他のコンポーネントをあたかも自分の一部の機能であるかのように使用しタスクを遂行することができます。
また、CORBA、DCOMといった汎用的な分散オブジェクトミドルウェアも確立されていますが、RTミドルウェアとそれらとの一番大きな違いは、コンポーネント自身がアクティブに動作すること、上記コンポーネント間の密な連携など、RTシステムに固有な機能をサポートしていることです。

\subsubsection*{高いスケーラビリティを有したコンポーネント化が可能}
旧来の単体のロボット単位におけるコンポーネント化では、それぞれのコンポーネントを組み合わせて新しいロボットシステムを構築することは困難でした。
RT関連技術を機能要素単位でモジュール化し部品化することにより、新しいロボットシステムの構築のみならず、ロボット以外の分野へもRTの活用が開かれます。
さらに、RTミドルウェアでは、同一のフレームワークで、装置レベルまでも広くカバーすることが可能です。
この高いスケーラビリティにより、コンポーネント化の粒度を、RTを部品として提供しようとしているもの及びそれを利用しようとしているものが必要に応じて自由に選ぶことができ、粒度の異なるコンポーネントを自在に組み合わせるなどの応用面においても、幅広い選択が可能となります。
 
\subsubsection*{プラットフォーム、ネットワーク非依存}
特定の計算機やOS、特定のネットワークに限定されては、自由な粒度でモジュール化を行うことは困難です。
RTミドルウェアの考え方は、特定のアーキテクチャに依存しないものですので、各CPUやOS、ネットワークインタフェース(デバイス)に適用可能です。
RTMでは基本的にCORBAが使用可能なプラットフォームであれば、OS、言語を問わず実装することが出来ます。

\subsubsection*{既存のソフトウェア資産の再利用が可能である}
RTミドルウエアではソフトウエア資源の再利用が容易になり、導入の敷居が低くなるようにフレームワークやツール群などを用意しています。
また、一旦完成したコンポーネントは、開発者以外にも再利用可能であり、インテグレータのアイデア次第で多種多様なシステムを実現できるでしょう。

\subsubsection*{国際標準に基づいた仕様策定}
RTミドルウェアは、ネットワーク通信のためのミドルウェアとして OMG (Object Management Group)\index{OMG} の策定した CORBA を採用しています。
また、RTミドルウェア自体は、OMGのSDOモデルへのマッピング作業が行われており、標準化を意識した仕様策定を行っています。
この標準化作業の過程で、ロボットの分散モジュール化およびその仕様の標準化はOMGで重要視され始め、MDA(Model Driven Architecture)\index{MDA} に基づくロボットソフトウェア開発のための標準化作業も始まろうとしています。

\section{RTミドルウエア・RTコンポーネント}
RTミドルウエアとは、上述したようにRTのためのプラットフォームでありそのためのミドルウエアをさします。
図~\ref{fig:RTMiddleware}はRTミドルウエアの概観図です。
RTミドルウエアは、
\begin{itemize}
\item コンポーネントフレームワーク\index{フレームワーク}、
\item 標準的に再利用されるソフトウエア部品群、
\item ライブラリ群、
\item 標準サービス群
\end{itemize}
などから構成されます。

\begin{figure}[H]
\centering{\epsfile{file=figs/RTMiddleware_and_RTComponents.eps,width=0.9\columnwidth}}
\caption{RTミドルウエア}
\label{fig:RTMiddleware}
\end{figure}

RTミドルウエアのうち、RTシステムを構成する主体となるソフトウエア部品群をRTコンポーネント\index{RTコンポーネント}と呼びます。
RTコンポーネントは通常、上記のRTコンポーネントフレームワーク\index{RTコンポーネントフレームワーク}を用いて作成されます。
既存のRTコンポーネントを利用したり、自分で開発したRTコンポーネントを部品のように組み合わせることで目的とするシステムを作成します。
RTコンポーネント群を使用するために必要な機能で、コンポーネント自身にないものはいつかのサービス群を利用することが出来ます。
また、コンポーネントの作成を助けるライブラリなども提供することを想定しています。

以上の全てをまとめたものをRTミドルウエア\index{RTミドルウエア}と呼びます。



\section{RTコンポーネント\index{RTコンポーネント}}
RTコンポーネントの基本的構造を説明します。
図~\ref{fig:RtComponent}はRTコンポーネントのアーキテクチャ・ブロック図です。
RTコンポーネントの仕様ではネットワーク上に分散されたコンポーネントへの透過的アクセスを実現するために、分散オブジェクト技術を用いて実装されることを想定しています。

OpenRTM\--aist では、OS・言語非依存性を重視してCORBAを用いて実装されています。

\begin{figure}[H]
\centering{\epsfile{file=figs/RtComponent_bw.eps,width=1.0\columnwidth}}
\caption{RTコンポーネント}
\label{fig:RtComponent}
\end{figure}

通常の分散オブジェクトでは、データのやり取りは基本的にメソッド呼び出しを介して行われます。
これに対して、ロボットの制御における入出力データストリームは、通常メソッドよりもデータ型が重要な意味を持ちます。

例えば、6自由度を持つジョイスティックがあり、これが出力する6個のdouble型データを用いて対象(マニピュレータ、移動ロボット、ヒューマノイド等)を様々な方式(位置制御、速度制御、インピーダンス制御等)で制御したいとします。
単なる分散オブジェクトとしてシステムを構成するならば、ジョイスティックはあらゆるタイプの制御対象のメソッド(インターフェース)を予め知っていなければなりません。
しかしながら、実際には送り手が6個のdouble型データを送ることができ、受け手も6個のdouble型データを処理して動作することができれば十分なのです。
RTコンポーネントはこういったデータ交換のために、データ型が同じであれば接続可能なInPort/OutPort\index{InPort}\index{OutPort}と呼ばれるデータポートを持っています。

RTコンポーネントはいくつかのオブジェクトから構成されており、大きく分けると以下の3つの部分から成ります。

\begin{description}
\item[RTComponent\index{RTComponent}]
RTコンポーネントの本体であり、基本的なインターフェースおよび入出力を行うInPort/OutPortオブジェクトを0$\sim$n個以上持つ。
処理を行うコアロジックを1個持ち、外部または内部からのイベントに応じて内部状態を遷移させる。
これをActivityと呼び、他とは独立したスレッドに割り当てられ以下に挙げる入出力とは独立に処理が行われる。

\item[InPort\index{InPort}]
他のRTコンポーネントからの出力をを受け取りハンドリングする入力ポート。
データのストリームを受け取る必要があるRTコンポーネントはこのInPortを持つ。
コアロジックは連続的に送られてくるデータに対して処理を行うため、基本的に周期動作を行うコンポーネントのみがこのInPortを持つ。

\item[OutPort\index{OutPort}]
他のRTコンポーネントへ処理結果のデータストリームを渡す出力ポート。
受け取る側のコンポーネントから値を取得するpull型のデータ出力と、サブスクライブすることにより受け取り側へ能動的にデータを送るpush型の動作がある。
\end{description}

OpenRTM\--aist\index{OpenRTM} では、上記の構造を持つRTコンポーネントを簡単に作成できるフレームワークやツール群があります。
これらを使用することで、既存のソフトウエア資産(ロボット制御用ライブラリ等)にコンポーネントの皮に包むことができます。
さらに、一旦コンポーネント化されたソフトウエアは、仕様が変わらない限り、最コンパイルすることなく他のコンポーネントと組み合わせシステムを構築することが出来るのです。


\section{RTコンポーネント、マネージャ、ネームサービス}
上述したように、RTコンポーネントは、ロボットシステムを構築するための様々な機能を持っていますが、RTコンポーネントだけでは意味のあるシステムを作ることは出来ません。
幾つかのホスト上で動作するコンポーネントを検索し、接続、起動、停止するなど操作を行う必要があります。

OpenRTM\--aist においては、RTコンポーネントのライフサイクルの管理、ネームサーバへの登録などを一括して行うオブジェクトとしてコンポーネントマネージャを提供しています。

コンポーネントとマネージャやネームサービスなどの関係は図~\ref{fig:RTM_Manager_and_NS}のようになっています。

コンポーネントは通常、ロード可能なライブラリ形式(=モジュールと呼ぶ)で提供され、マネージャはこのモジュールをロードし、インスタンス化することでコンポーネントを生成します。

また、マネージャは生成したコンポーネントがネットワーク上の他のホストからも検索できるように、CORBAネーミングサービスを使用して、ネームサーバへコンポーネントの名前とオブジェクトリファレンスを登録します。
また、コンポーネントはマネージャを通してネームサーバに対して問い合わせることにより、他のコンポーネントを名前で検索することも出来ます。

\begin{figure}[H]
\centering{\epsfile{file=figs/RTM_Manager_and_NS.eps,width=1.0\columnwidth}}
\caption{RTコンポーネント、マネージャ、ネームサービス}
\label{fig:RTM_Manager_and_NS}
\end{figure}

